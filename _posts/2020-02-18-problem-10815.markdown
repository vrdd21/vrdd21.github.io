---
layout: post
title:  "Problem #10815"
description:
date:   2020-02-18 17:57:00 +0530
categories: C++
---

### 숫자 카드
###### [문제 사이트](https://www.acmicpc.net/problem/10815)

- - -

### 문제 유형

- - -

이분 탐색 (Binary Search)

- - -

### 문제 설명

- - -

| 시간 제한 | 메모리 제한 |
|--------|--------|
|    2초    |   256 MB     |

숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.

첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이가 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다. 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.

셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다. 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다. 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다

**예시**
| 입력 | 출력 |
|--------|--------|
|5<br>6 3 2 10 -10<br>8<br>10 9 -5 2 3 4 5 -10        |   1 0 0 1 1 0 0 1     |

** 요약 **

주어진 M 개의 정수 중 상근이가 가지고 있는 N개의 숫자와 겹치는 것을 찾고 출력해라.

- - -

### 문제 풀이

- - -

**Motive**
M 개의 정수와 N 개의 정수를 일일이 비교한다면 시간 복잡도는 O(M*N)이다. 데이터셋의 최대 경우를 생각해보면 500,000 * 500,000인데 2500억이 나온다. 1억번 계산에 1초라고 한다면 2500초가 되므로 문제의 제한시간인 2초를 훌쩍 넘긴다.

따라서 시간복잡도를 최소한 O(M*log(N)) 정도로 낮춰야 하고 이 경우 계산 횟수는 285만 번이 된다. 그러므로 N을 정렬한 후 M 개의 정수 각각을 이분 탐색을 통해 찾으면 위에서 말한 시간 복잡도를 만족시킬 수 있다.

```
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

int main(void)
{
	int n, m;
	int* card, * filter, * answer;

	scanf("%d", &n);

	card = new int[n];

	for (int i = 0; i < n; i++)
	{
		scanf("%d", &card[i]);
	}

	scanf("%d", &m);

	filter = new int[m];
	answer = new int[m];

	memset(answer, 0, sizeof(answer));

	for (int i = 0; i < m; i++)
	{
		scanf("%d",&filter[i]);
	}

	sort(card, card + n);

	int low, high, med;

	for (int i = 0; i < m; i++)
	{
		low = 0, high = n;
		while (1)
		{
			if (low > high)
			{
				answer[i] = 0;
				break;
			}

			med = (low + high) / 2;

			if (card[med] == filter[i])
			{
				answer[i] = 1;
				break;
			}
			else if (card[med] < filter[i])
			{
				low = med + 1;
			}
			else
			{
				high = med - 1;
			}
		}
	}

	for (int i = 0; i < m; i++)
		printf("%d ", answer[i]);
	return 0;
}
```


- - -

### 개선할 부분

- - -

이러이러한게 아쉬웠고 아니면 시간복잡도나 공간복잡도 제한이 추가된다면 이렇게 풀긴 힘들거같아요

- - -
